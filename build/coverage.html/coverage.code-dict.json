{"/home/travis/build/npmtest/node-npmtest-voxel/test.js":"/* istanbul instrument in package npmtest_voxel */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-voxel/lib.npmtest_voxel.js":"/* istanbul instrument in package npmtest_voxel */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_voxel = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_voxel = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-voxel/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-voxel && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_voxel */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_voxel\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_voxel.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_voxel.rollup.js'] =\n            local.assetsDict['/assets.npmtest_voxel.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_voxel.__dirname + '/lib.npmtest_voxel.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-voxel/node_modules/voxel/index.js":"var chunker = require('./chunker')\nvar ndarray = require('ndarray')\n\nmodule.exports = function(opts) {\n  if (!opts.generateVoxelChunk) opts.generateVoxelChunk = function(low, high) {\n    return generate(low, high, module.exports.generator['Valley'])\n  }\n  return chunker(opts)\n}\n\nmodule.exports.meshers = {\n  culled: require('./meshers/culled').mesher,\n  greedy: require('./meshers/greedy').mesher,\n  transgreedy: require('./meshers/transgreedy').mesher,\n  monotone: require('./meshers/monotone').mesher,\n  stupid: require('./meshers/stupid').mesher\n}\n\nmodule.exports.Chunker = chunker.Chunker\nmodule.exports.geometry = {}\nmodule.exports.generator = {}\nmodule.exports.generate = generate\n\nfunction generate(lo, hi, fn, game) {\n  // To fix the display gaps, we need to pad the bounds\n  lo[0]--\n  lo[1]--\n  lo[2]--\n  hi[0]++\n  hi[1]++\n  hi[2]++\n  var dims = [hi[2]-lo[2], hi[1]-lo[1], hi[0]-lo[0]]\n  var data = ndarray(new Uint16Array(dims[2] * dims[1] * dims[0]), dims)\n  for (var k = lo[2]; k < hi[2]; k++)\n    for (var j = lo[1]; j < hi[1]; j++)\n      for(var i = lo[0]; i < hi[0]; i++) {\n        data.set(k-lo[2], j-lo[1], i-lo[0], fn(i, j, k))\n      }\n  return data\n}\n\n// shape and terrain generator functions\nmodule.exports.generator['Sphere'] = function(i,j,k) {\n  return i*i+j*j+k*k <= 16*16 ? 1 : 0\n}\n\nmodule.exports.generator['Noise'] = function(i,j,k) {\n  return Math.random() < 0.1 ? Math.random() * 0xffffff : 0;\n}\n\nmodule.exports.generator['Dense Noise'] = function(i,j,k) {\n  return Math.round(Math.random() * 0xffffff);\n}\n\nmodule.exports.generator['Checker'] = function(i,j,k) {\n  return !!((i+j+k)&1) ? (((i^j^k)&2) ? 1 : 0xffffff) : 0;\n}\n\nmodule.exports.generator['Hill'] = function(i,j,k) {\n  return j <= 16 * Math.exp(-(i*i + k*k) / 64) ? 1 : 0;\n}\n\nmodule.exports.generator['Valley'] = function(i,j,k) {\n  return j <= (i*i + k*k) * 31 / (32*32*2) + 1 ? 1 + (1<<15) : 0;\n}\n\nmodule.exports.generator['Hilly Terrain'] = function(i,j,k) {\n  var h0 = 3.0 * Math.sin(Math.PI * i / 12.0 - Math.PI * k * 0.1) + 27;    \n  if(j > h0+1) {\n    return 0;\n  }\n  if(h0 <= j) {\n    return 1;\n  }\n  var h1 = 2.0 * Math.sin(Math.PI * i * 0.25 - Math.PI * k * 0.3) + 20;\n  if(h1 <= j) {\n    return 2;\n  }\n  if(2 < j) {\n    return Math.random() < 0.1 ? 0x222222 : 0xaaaaaa;\n  }\n  return 3;\n}\n\nmodule.exports.scale = function ( x, fromLow, fromHigh, toLow, toHigh ) {\n  return ( x - fromLow ) * ( toHigh - toLow ) / ( fromHigh - fromLow ) + toLow\n}\n\n// convenience function that uses the above functions to prebake some simple voxel geometries\nmodule.exports.generateExamples = function() {\n  return {\n    'Sphere': generate([-16,-16,-16], [16,16,16], module.exports.generator['Sphere']),\n    'Noise': generate([0,0,0], [16,16,16], module.exports.generator['Noise']),\n    'Dense Noise': generate([0,0,0], [16,16,16], module.exports.generator['Dense Noise']),\n    'Checker': generate([0,0,0], [8,8,8], module.exports.generator['Checker']),\n    'Hill': generate([-16, 0, -16], [16,16,16], module.exports.generator['Hill']),\n    'Valley': generate([0,0,0], [32,32,32], module.exports.generator['Valley']),\n    'Hilly Terrain': generate([0, 0, 0], [32,32,32], module.exports.generator['Hilly Terrain'])\n  }\n}\n\n","/home/travis/build/npmtest/node-npmtest-voxel/node_modules/voxel/chunker.js":"var events = require('events')\nvar inherits = require('inherits')\n\nmodule.exports = function(opts) {\n  return new Chunker(opts)\n}\n\nmodule.exports.Chunker = Chunker\n\nfunction Chunker(opts) {\n  this.distance = opts.chunkDistance || 2\n  this.chunkSize = opts.chunkSize || 32\n  this.chunkPad = opts.chunkPad !== undefined ? opts.chunkPad : 0\n  this.cubeSize = opts.cubeSize || 25\n  this.generateVoxelChunk = opts.generateVoxelChunk\n  this.chunks = {}\n  this.meshes = {}\n\n  if (this.chunkSize & this.chunkSize-1 !== 0)\n    throw new Error('chunkSize must be a power of 2')\n  var bits = 0;\n  for (var size = this.chunkSize; size > 0; size >>= 1) bits++;\n  this.chunkBits = bits - 1;\n  this.chunkMask = (1 << this.chunkBits) - 1\n  this.chunkPadHalf = this.chunkPad >> 1\n}\n\ninherits(Chunker, events.EventEmitter)\n\nChunker.prototype.nearbyChunks = function(position, distance) {\n  var current = this.chunkAtPosition(position)\n  var x = current[0]\n  var y = current[1]\n  var z = current[2]\n  var dist = distance || this.distance\n  var nearby = []\n  for (var cx = (x - dist); cx !== (x + dist); ++cx) {\n    for (var cy = (y - dist); cy !== (y + dist); ++cy) {\n      for (var cz = (z - dist); cz !== (z + dist); ++cz) {\n        nearby.push([cx, cy, cz])\n      }\n    }\n  }\n  return nearby\n}\n\nChunker.prototype.requestMissingChunks = function(position) {\n  var self = this\n  this.nearbyChunks(position).map(function(chunk) {\n    if (!self.chunks[chunk.join('|')]) {\n      self.emit('missingChunk', chunk)\n    }\n  })\n}\n\nChunker.prototype.getBounds = function(x, y, z) {\n  var bits = this.chunkBits\n  var low = [x << bits, y << bits, z << bits]\n  var high = [(x+1) << bits, (y+1) << bits, (z+1) << bits]\n  return [low, high]\n}\n\nChunker.prototype.generateChunk = function(x, y, z) {\n  var self = this\n  var bounds = this.getBounds(x, y, z)\n  var chunk = this.generateVoxelChunk(bounds[0], bounds[1], x, y, z)\n  var position = [x, y, z]\n  chunk.position = position\n  this.chunks[position.join('|')] = chunk\n  return chunk\n}\n\nChunker.prototype.chunkAtCoordinates = function(x, y, z) {\n  var bits = this.chunkBits;\n  var cx = x >> bits;\n  var cy = y >> bits;\n  var cz = z >> bits;\n  var chunkPos = [cx, cy, cz];\n  return chunkPos;\n}\n\nChunker.prototype.chunkAtPosition = function(position) {\n  var cubeSize = this.cubeSize;\n  var x = Math.floor(position[0] / cubeSize)\n  var y = Math.floor(position[1] / cubeSize)\n  var z = Math.floor(position[2] / cubeSize)\n  var chunkPos = this.chunkAtCoordinates(x, y, z)\n  return chunkPos\n};\n\nChunker.prototype.voxelIndexFromCoordinates = function(x, y, z) {\n  throw new Error('Chunker.prototype.voxelIndexFromCoordinates removed, use voxelAtCoordinates')\n}\n\nChunker.prototype.voxelAtCoordinates = function(x, y, z, val) {\n  var ckey = this.chunkAtCoordinates(x, y, z).join('|')\n  var chunk = this.chunks[ckey]\n  if (!chunk) return false\n  var mask = this.chunkMask\n  var h = this.chunkPadHalf\n  var mx = x & mask\n  var my = y & mask\n  var mz = z & mask\n  var v = chunk.get(mx+h, my+h, mz+h)\n  if (typeof val !== 'undefined') {\n    chunk.set(mx+h, my+h, mz+h, val)\n  }\n  return v\n}\n\nChunker.prototype.voxelAtPosition = function(pos, val) {\n  var cubeSize = this.cubeSize;\n  var x = Math.floor(pos[0] / cubeSize)\n  var y = Math.floor(pos[1] / cubeSize)\n  var z = Math.floor(pos[2] / cubeSize)\n  var v = this.voxelAtCoordinates(x, y, z, val)\n  return v;\n}\n\n","/home/travis/build/npmtest/node-npmtest-voxel/node_modules/voxel/meshers/culled.js":"//Naive meshing (with face culling)\nfunction CulledMesh(volume, dims) {\n  //Precalculate direction vectors for convenience\n  var dir = new Array(3);\n  for(var i=0; i<3; ++i) {\n    dir[i] = [[0,0,0], [0,0,0]];\n    dir[i][0][(i+1)%3] = 1;\n    dir[i][1][(i+2)%3] = 1;\n  }\n  //March over the volume\n  var vertices = []\n    , faces = []\n    , x = [0,0,0]\n    , B = [[false,true]    //Incrementally update bounds (this is a bit ugly)\n          ,[false,true]\n          ,[false,true]]\n    , n = -dims[0]*dims[1];\n  for(           B[2]=[false,true],x[2]=-1; x[2]<dims[2]; B[2]=[true,(++x[2]<dims[2]-1)])\n  for(n-=dims[0],B[1]=[false,true],x[1]=-1; x[1]<dims[1]; B[1]=[true,(++x[1]<dims[1]-1)])\n  for(n-=1,      B[0]=[false,true],x[0]=-1; x[0]<dims[0]; B[0]=[true,(++x[0]<dims[0]-1)], ++n) {\n    //Read current voxel and 3 neighboring voxels using bounds check results\n    var p =   (B[0][0] && B[1][0] && B[2][0]) ? volume[n]                 : 0\n      , b = [ (B[0][1] && B[1][0] && B[2][0]) ? volume[n+1]               : 0\n            , (B[0][0] && B[1][1] && B[2][0]) ? volume[n+dims[0]]         : 0\n            , (B[0][0] && B[1][0] && B[2][1]) ? volume[n+dims[0]*dims[1]] : 0\n          ];\n    //Generate faces\n    for(var d=0; d<3; ++d)\n    if((!!p) !== (!!b[d])) {\n      var s = !p ? 1 : 0;\n      var t = [x[0],x[1],x[2]]\n        , u = dir[d][s]\n        , v = dir[d][s^1];\n      ++t[d];\n      \n      var vertex_count = vertices.length;\n      vertices.push([t[0],           t[1],           t[2]          ]);\n      vertices.push([t[0]+u[0],      t[1]+u[1],      t[2]+u[2]     ]);\n      vertices.push([t[0]+u[0]+v[0], t[1]+u[1]+v[1], t[2]+u[2]+v[2]]);\n      vertices.push([t[0]     +v[0], t[1]     +v[1], t[2]     +v[2]]);\n      faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, s ? b[d] : p]);\n    }\n  }\n  return { vertices:vertices, faces:faces };\n}\n\n\nif(exports) {\n  exports.mesher = CulledMesh;\n}\n","/home/travis/build/npmtest/node-npmtest-voxel/node_modules/voxel/meshers/greedy.js":"var GreedyMesh = (function() {\n//Cache buffer internally\nvar mask = new Int32Array(4096);\n\nreturn function(volume, dims) {\n  var vertices = [], faces = []\n    , dimsX = dims[0]\n    , dimsY = dims[1]\n    , dimsXY = dimsX * dimsY;\n\n  //Sweep over 3-axes\n  for(var d=0; d<3; ++d) {\n    var i, j, k, l, w, W, h, n, c\n      , u = (d+1)%3\n      , v = (d+2)%3\n      , x = [0,0,0]\n      , q = [0,0,0]\n      , du = [0,0,0]\n      , dv = [0,0,0]\n      , dimsD = dims[d]\n      , dimsU = dims[u]\n      , dimsV = dims[v]\n      , qdimsX, qdimsXY\n      , xd\n\n    if (mask.length < dimsU * dimsV) {\n      mask = new Int32Array(dimsU * dimsV);\n    }\n\n    q[d] =  1;\n    x[d] = -1;\n\n    qdimsX  = dimsX  * q[1]\n    qdimsXY = dimsXY * q[2]\n\n    // Compute mask\n    while (x[d] < dimsD) {\n      xd = x[d]\n      n = 0;\n\n      for(x[v] = 0; x[v] < dimsV; ++x[v]) {\n        for(x[u] = 0; x[u] < dimsU; ++x[u], ++n) {\n          var a = xd >= 0      && volume[x[0]      + dimsX * x[1]          + dimsXY * x[2]          ]\n            , b = xd < dimsD-1 && volume[x[0]+q[0] + dimsX * x[1] + qdimsX + dimsXY * x[2] + qdimsXY]\n          if (a ? b : !b) {\n            mask[n] = 0; continue;\n          }\n          mask[n] = a ? a : -b;\n        }\n      }\n\n      ++x[d];\n\n      // Generate mesh for mask using lexicographic ordering\n      n = 0;\n      for (j=0; j < dimsV; ++j) {\n        for (i=0; i < dimsU; ) {\n          c = mask[n];\n          if (!c) {\n            i++;  n++; continue;\n          }\n\n          //Compute width\n          w = 1;\n          while (c === mask[n+w] && i+w < dimsU) w++;\n\n          //Compute height (this is slightly awkward)\n          for (h=1; j+h < dimsV; ++h) {\n            k = 0;\n            while (k < w && c === mask[n+k+h*dimsU]) k++\n            if (k < w) break;\n          }\n\n          // Add quad\n          // The du/dv arrays are reused/reset\n          // for each iteration.\n          du[d] = 0; dv[d] = 0;\n          x[u]  = i;  x[v] = j;\n\n          if (c > 0) {\n            dv[v] = h; dv[u] = 0;\n            du[u] = w; du[v] = 0;\n          } else {\n            c = -c;\n            du[v] = h; du[u] = 0;\n            dv[u] = w; dv[v] = 0;\n          }\n          var vertex_count = vertices.length;\n          vertices.push([x[0],             x[1],             x[2]            ]);\n          vertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);\n          vertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);\n          vertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);\n          faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, c]);\n\n          //Zero-out mask\n          W = n + w;\n          for(l=0; l<h; ++l) {\n            for(k=n; k<W; ++k) {\n              mask[k+l*dimsU] = 0;\n            }\n          }\n\n          //Increment counters and continue\n          i += w; n += w;\n        }\n      }\n    }\n  }\n  return { vertices:vertices, faces:faces };\n}\n})();\n\nif(exports) {\n  exports.mesher = GreedyMesh;\n}\n","/home/travis/build/npmtest/node-npmtest-voxel/node_modules/voxel/meshers/transgreedy.js":"var GreedyMesh = (function greedyLoader() {\n    \n// contains all forward faces (in terms of scan direction)\nvar mask = new Int32Array(4096);\n// and all backwards faces. needed when there are two transparent blocks\n// next to each other.\nvar invMask = new Int32Array(4096);\n\n// setting 16th bit if transparent\nvar kTransparentMask    = 0x8000;\nvar kNoFlagsMask        = 0x7FFF;\nvar kTransparentTypes   = [];\n\nkTransparentTypes[16] = true\n\nfunction isTransparent(v) {\n  return (v & kTransparentMask) === kTransparentMask;\n}\n\nfunction removeFlags(v) {\n  return (v & kNoFlagsMask);\n}\n\nreturn function ohSoGreedyMesher(volume, dims, mesherExtraData) {\n  var vertices = [], faces = []\n    , dimsX = dims[0]\n    , dimsY = dims[1]\n    , dimsXY = dimsX * dimsY;\n\n  var tVertices = [], tFaces = []\n\n  var transparentTypes = mesherExtraData ? (mesherExtraData.transparentTypes || {}) : {};\n  var getType = function(voxels, offset) {\n    var type = voxels[offset];\n    return type | (type in transparentTypes ? kTransparentMask : 0);\n  }\n\n\n  //Sweep over 3-axes\n  for(var d=0; d<3; ++d) {\n    var i, j, k, l, w, W, h, n, c\n      , u = (d+1)%3\n      , v = (d+2)%3\n      , x = [0,0,0]\n      , q = [0,0,0]\n      , du = [0,0,0]\n      , dv = [0,0,0]\n      , dimsD = dims[d]\n      , dimsU = dims[u]\n      , dimsV = dims[v]\n      , qdimsX, qdimsXY\n      , xd\n\n    if (mask.length < dimsU * dimsV) {\n      mask = new Int32Array(dimsU * dimsV);\n      invMask = new Int32Array(dimsU * dimsV);\n    }\n\n    q[d] =  1;\n    x[d] = -1;\n\n    qdimsX  = dimsX  * q[1]\n    qdimsXY = dimsXY * q[2]\n\n    // Compute mask\n    while (x[d] < dimsD) {\n      xd = x[d]\n      n = 0;\n\n      for(x[v] = 0; x[v] < dimsV; ++x[v]) {\n        for(x[u] = 0; x[u] < dimsU; ++x[u], ++n) {\n          // Modified to read through getType()\n          var a = xd >= 0      && getType(volume, x[0]      + dimsX * x[1]          + dimsXY * x[2]          )\n            , b = xd < dimsD-1 && getType(volume, x[0]+q[0] + dimsX * x[1] + qdimsX + dimsXY * x[2] + qdimsXY)\n\n          // both are transparent, add to both directions\n          if (isTransparent(a) && isTransparent(b)) {\n            mask[n] = a;\n            invMask[n] = b;\n          // if a is solid and b is not there or transparent\n          } else if (a && (!b || isTransparent(b))) {\n            mask[n] = a;\n            invMask[n] = 0\n          // if b is solid and a is not there or transparent\n          } else if (b && (!a || isTransparent(a))) {\n            mask[n] = 0\n            invMask[n] = b;\n          // dont draw this face\n          } else {\n            mask[n] = 0\n            invMask[n] = 0\n          }\n        }\n      }\n\n      ++x[d];\n\n      // Generate mesh for mask using lexicographic ordering\n      function generateMesh(mask, dimsV, dimsU, vertices, faces, clockwise) {\n        clockwise = clockwise === undefined ? true : clockwise;\n        var n, j, i, c, w, h, k, du = [0,0,0], dv = [0,0,0];\n        n = 0;\n        for (j=0; j < dimsV; ++j) {\n          for (i=0; i < dimsU; ) {\n            c = mask[n];\n            if (!c) {\n              i++;  n++; continue;\n            }\n\n            //Compute width\n            w = 1;\n            while (c === mask[n+w] && i+w < dimsU) w++;\n\n            //Compute height (this is slightly awkward)\n            for (h=1; j+h < dimsV; ++h) {\n              k = 0;\n              while (k < w && c === mask[n+k+h*dimsU]) k++\n              if (k < w) break;\n            }\n\n            // Add quad\n            // The du/dv arrays are reused/reset\n            // for each iteration.\n            du[d] = 0; dv[d] = 0;\n            x[u]  = i;  x[v] = j;\n\n            if (clockwise) {\n            // if (c > 0) {\n              dv[v] = h; dv[u] = 0;\n              du[u] = w; du[v] = 0;\n            } else {\n              // c = -c;\n              du[v] = h; du[u] = 0;\n              dv[u] = w; dv[v] = 0;\n            }\n            \n            // ## enable code to ensure that transparent faces are last in the list\n            // if (!isTransparent(c)) {\n              var vertex_count = vertices.length;\n              vertices.push([x[0],             x[1],             x[2]            ]);\n              vertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);\n              vertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);\n              vertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);\n              faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, removeFlags(c)]);\n            // } else {\n            //   var vertex_count = tVertices.length;\n            //   tVertices.push([x[0],             x[1],             x[2]            ]);\n            //   tVertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);\n            //   tVertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);\n            //   tVertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);\n            //   tFaces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, removeFlags(c)]);\n            // }\n\n            //Zero-out mask\n            W = n + w;\n            for(l=0; l<h; ++l) {\n              for(k=n; k<W; ++k) {\n                mask[k+l*dimsU] = 0;\n              }\n            }\n\n            //Increment counters and continue\n            i += w; n += w;\n          }\n        }\n      }\n      generateMesh(mask, dimsV, dimsU, vertices, faces, true)\n      generateMesh(invMask, dimsV, dimsU, vertices, faces, false)\n    }\n  }\n  \n  // ## enable code to ensure that transparent faces are last in the list\n  // var vertex_count = vertices.length;\n  // var newFaces = tFaces.map(function(v) {\n  //   return [vertex_count+v[0], vertex_count+v[1], vertex_count+v[2], vertex_count+v[3], v[4]]\n  // })\n  // \n  // return { vertices:vertices.concat(tVertices), faces:faces.concat(newFaces) };\n  \n  // TODO: Try sorting by texture to see if we can reduce draw calls.\n  // faces.sort(function sortFaces(a, b) {\n  //   return b[4] - a[4];\n  // })\n  return { vertices:vertices, faces:faces };\n}\n})();\n\nif(exports) {\n  exports.mesher = GreedyMesh;\n}\n","/home/travis/build/npmtest/node-npmtest-voxel/node_modules/voxel/meshers/monotone.js":"\"use strict\";\n\nvar MonotoneMesh = (function(){\n\nfunction MonotonePolygon(c, v, ul, ur) {\n  this.color  = c;\n  this.left   = [[ul, v]];\n  this.right  = [[ur, v]];\n};\n\nMonotonePolygon.prototype.close_off = function(v) {\n  this.left.push([ this.left[this.left.length-1][0], v ]);\n  this.right.push([ this.right[this.right.length-1][0], v ]);\n};\n\nMonotonePolygon.prototype.merge_run = function(v, u_l, u_r) {\n  var l = this.left[this.left.length-1][0]\n    , r = this.right[this.right.length-1][0]; \n  if(l !== u_l) {\n    this.left.push([ l, v ]);\n    this.left.push([ u_l, v ]);\n  }\n  if(r !== u_r) {\n    this.right.push([ r, v ]);\n    this.right.push([ u_r, v ]);\n  }\n};\n\n\nreturn function(volume, dims) {\n  function f(i,j,k) {\n    return volume[i + dims[0] * (j + dims[1] * k)];\n  }\n  //Sweep over 3-axes\n  var vertices = [], faces = [];\n  for(var d=0; d<3; ++d) {\n    var i, j, k\n      , u = (d+1)%3   //u and v are orthogonal directions to d\n      , v = (d+2)%3\n      , x = new Int32Array(3)\n      , q = new Int32Array(3)\n      , runs = new Int32Array(2 * (dims[u]+1))\n      , frontier = new Int32Array(dims[u])  //Frontier is list of pointers to polygons\n      , next_frontier = new Int32Array(dims[u])\n      , left_index = new Int32Array(2 * dims[v])\n      , right_index = new Int32Array(2 * dims[v])\n      , stack = new Int32Array(24 * dims[v])\n      , delta = [[0,0], [0,0]];\n    //q points along d-direction\n    q[d] = 1;\n    //Initialize sentinel\n    for(x[d]=-1; x[d]<dims[d]; ) {\n      // --- Perform monotone polygon subdivision ---\n      var n = 0\n        , polygons = []\n        , nf = 0;\n      for(x[v]=0; x[v]<dims[v]; ++x[v]) {\n        //Make one pass over the u-scan line of the volume to run-length encode polygon\n        var nr = 0, p = 0, c = 0;\n        for(x[u]=0; x[u]<dims[u]; ++x[u], p = c) {\n          //Compute the type for this face\n          var a = (0    <= x[d]      ? f(x[0],      x[1],      x[2])      : 0)\n            , b = (x[d] <  dims[d]-1 ? f(x[0]+q[0], x[1]+q[1], x[2]+q[2]) : 0);\n          c = a;\n          if((!a) === (!b)) {\n            c = 0;\n          } else if(!a) {\n            c = -b;\n          }\n          //If cell type doesn't match, start a new run\n          if(p !== c) {\n            runs[nr++] = x[u];\n            runs[nr++] = c;\n          }\n        }\n        //Add sentinel run\n        runs[nr++] = dims[u];\n        runs[nr++] = 0;\n        //Update frontier by merging runs\n        var fp = 0;\n        for(var i=0, j=0; i<nf && j<nr-2; ) {\n          var p    = polygons[frontier[i]]\n            , p_l  = p.left[p.left.length-1][0]\n            , p_r  = p.right[p.right.length-1][0]\n            , p_c  = p.color\n            , r_l  = runs[j]    //Start of run\n            , r_r  = runs[j+2]  //End of run\n            , r_c  = runs[j+1]; //Color of run\n          //Check if we can merge run with polygon\n          if(r_r > p_l && p_r > r_l && r_c === p_c) {\n            //Merge run\n            p.merge_run(x[v], r_l, r_r);\n            //Insert polygon into frontier\n            next_frontier[fp++] = frontier[i];\n            ++i;\n            j += 2;\n          } else {\n            //Check if we need to advance the run pointer\n            if(r_r <= p_r) {\n              if(!!r_c) {\n                var n_poly = new MonotonePolygon(r_c, x[v], r_l, r_r);\n                next_frontier[fp++] = polygons.length;\n                polygons.push(n_poly);\n              }\n              j += 2;\n            }\n            //Check if we need to advance the frontier pointer\n            if(p_r <= r_r) {\n              p.close_off(x[v]);\n              ++i;\n            }\n          }\n        }\n        //Close off any residual polygons\n        for(; i<nf; ++i) {\n          polygons[frontier[i]].close_off(x[v]);\n        }\n        //Add any extra runs to frontier\n        for(; j<nr-2; j+=2) {\n          var r_l  = runs[j]\n            , r_r  = runs[j+2]\n            , r_c  = runs[j+1];\n          if(!!r_c) {\n            var n_poly = new MonotonePolygon(r_c, x[v], r_l, r_r);\n            next_frontier[fp++] = polygons.length;\n            polygons.push(n_poly);\n          }\n        }\n        //Swap frontiers\n        var tmp = next_frontier;\n        next_frontier = frontier;\n        frontier = tmp;\n        nf = fp;\n      }\n      //Close off frontier\n      for(var i=0; i<nf; ++i) {\n        var p = polygons[frontier[i]];\n        p.close_off(dims[v]);\n      }\n      // --- Monotone subdivision of polygon is complete at this point ---\n      \n      x[d]++;\n      \n      //Now we just need to triangulate each monotone polygon\n      for(var i=0; i<polygons.length; ++i) {\n        var p = polygons[i]\n          , c = p.color\n          , flipped = false;\n        if(c < 0) {\n          flipped = true;\n          c = -c;\n        }\n        for(var j=0; j<p.left.length; ++j) {\n          left_index[j] = vertices.length;\n          var y = [0.0,0.0,0.0]\n            , z = p.left[j];\n          y[d] = x[d];\n          y[u] = z[0];\n          y[v] = z[1];\n          vertices.push(y);\n        }\n        for(var j=0; j<p.right.length; ++j) {\n          right_index[j] = vertices.length;\n          var y = [0.0,0.0,0.0]\n            , z = p.right[j];\n          y[d] = x[d];\n          y[u] = z[0];\n          y[v] = z[1];\n          vertices.push(y);\n        }\n        //Triangulate the monotone polygon\n        var bottom = 0\n          , top = 0\n          , l_i = 1\n          , r_i = 1\n          , side = true;  //true = right, false = left\n        \n        stack[top++] = left_index[0];\n        stack[top++] = p.left[0][0];\n        stack[top++] = p.left[0][1];\n        \n        stack[top++] = right_index[0];\n        stack[top++] = p.right[0][0];\n        stack[top++] = p.right[0][1];\n        \n        while(l_i < p.left.length || r_i < p.right.length) {\n          //Compute next side\n          var n_side = false;\n          if(l_i === p.left.length) {\n            n_side = true;\n          } else if(r_i !== p.right.length) {\n            var l = p.left[l_i]\n              , r = p.right[r_i];\n            n_side = l[1] > r[1];\n          }\n          var idx = n_side ? right_index[r_i] : left_index[l_i]\n            , vert = n_side ? p.right[r_i] : p.left[l_i];\n          if(n_side !== side) {\n            //Opposite side\n            while(bottom+3 < top) {\n              if(flipped === n_side) {\n                faces.push([ stack[bottom], stack[bottom+3], idx, c]);\n              } else {\n                faces.push([ stack[bottom+3], stack[bottom], idx, c]);              \n              }\n              bottom += 3;\n            }\n          } else {\n            //Same side\n            while(bottom+3 < top) {\n              //Compute convexity\n              for(var j=0; j<2; ++j)\n              for(var k=0; k<2; ++k) {\n                delta[j][k] = stack[top-3*(j+1)+k+1] - vert[k];\n              }\n              var det = delta[0][0] * delta[1][1] - delta[1][0] * delta[0][1];\n              if(n_side === (det > 0)) {\n                break;\n              }\n              if(det !== 0) {\n                if(flipped === n_side) {\n                  faces.push([ stack[top-3], stack[top-6], idx, c ]);\n                } else {\n                  faces.push([ stack[top-6], stack[top-3], idx, c ]);\n                }\n              }\n              top -= 3;\n            }\n          }\n          //Push vertex\n          stack[top++] = idx;\n          stack[top++] = vert[0];\n          stack[top++] = vert[1];\n          //Update loop index\n          if(n_side) {\n            ++r_i;\n          } else {\n            ++l_i;\n          }\n          side = n_side;\n        }\n      }\n    }\n  }\n  return { vertices:vertices, faces:faces };\n}\n})();\n\nif(exports) {\n  exports.mesher = MonotoneMesh;\n}\n","/home/travis/build/npmtest/node-npmtest-voxel/node_modules/voxel/meshers/stupid.js":"//The stupidest possible way to generate a Minecraft mesh (I think)\nfunction StupidMesh(volume, dims) {\n  var vertices = [], faces = [], x = [0,0,0], n = 0;\n  for(x[2]=0; x[2]<dims[2]; ++x[2])\n  for(x[1]=0; x[1]<dims[1]; ++x[1])\n  for(x[0]=0; x[0]<dims[0]; ++x[0], ++n)\n  if(!!volume[n]) {\n    for(var d=0; d<3; ++d) {\n      var t = [x[0], x[1], x[2]]\n        , u = [0,0,0]\n        , v = [0,0,0];\n      u[(d+1)%3] = 1;\n      v[(d+2)%3] = 1;\n      for(var s=0; s<2; ++s) {\n        t[d] = x[d] + s;\n        var tmp = u;\n        u = v;\n        v = tmp;\n        var vertex_count = vertices.length;\n        vertices.push([t[0],           t[1],           t[2]          ]);\n        vertices.push([t[0]+u[0],      t[1]+u[1],      t[2]+u[2]     ]);\n        vertices.push([t[0]+u[0]+v[0], t[1]+u[1]+v[1], t[2]+u[2]+v[2]]);\n        vertices.push([t[0]     +v[0], t[1]     +v[1], t[2]     +v[2]]);\n        faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, volume[n]]);\n      }\n    }\n  }\n  return { vertices:vertices, faces:faces };\n}\n\n\nif(exports) {\n  exports.mesher = StupidMesh;\n}\n","/home/travis/build/npmtest/node-npmtest-voxel/node_modules/voxel/voxel-browser.js":"(function(){var require = function (file, cwd) {\n    var resolved = require.resolve(file, cwd || '/');\n    var mod = require.modules[resolved];\n    if (!mod) throw new Error(\n        'Failed to resolve module ' + file + ', tried ' + resolved\n    );\n    var cached = require.cache[resolved];\n    var res = cached? cached.exports : mod();\n    return res;\n};\n\nrequire.paths = [];\nrequire.modules = {};\nrequire.cache = {};\nrequire.extensions = [\".js\",\".coffee\",\".json\"];\n\nrequire._core = {\n    'assert': true,\n    'events': true,\n    'fs': true,\n    'path': true,\n    'vm': true\n};\n\nrequire.resolve = (function () {\n    return function (x, cwd) {\n        if (!cwd) cwd = '/';\n        \n        if (require._core[x]) return x;\n        var path = require.modules.path();\n        cwd = path.resolve('/', cwd);\n        var y = cwd || '/';\n        \n        if (x.match(/^(?:\\.\\.?\\/|\\/)/)) {\n            var m = loadAsFileSync(path.resolve(y, x))\n                || loadAsDirectorySync(path.resolve(y, x));\n            if (m) return m;\n        }\n        \n        var n = loadNodeModulesSync(x, y);\n        if (n) return n;\n        \n        throw new Error(\"Cannot find module '\" + x + \"'\");\n        \n        function loadAsFileSync (x) {\n            x = path.normalize(x);\n            if (require.modules[x]) {\n                return x;\n            }\n            \n            for (var i = 0; i < require.extensions.length; i++) {\n                var ext = require.extensions[i];\n                if (require.modules[x + ext]) return x + ext;\n            }\n        }\n        \n        function loadAsDirectorySync (x) {\n            x = x.replace(/\\/+$/, '');\n            var pkgfile = path.normalize(x + '/package.json');\n            if (require.modules[pkgfile]) {\n                var pkg = require.modules[pkgfile]();\n                var b = pkg.browserify;\n                if (typeof b === 'object' && b.main) {\n                    var m = loadAsFileSync(path.resolve(x, b.main));\n                    if (m) return m;\n                }\n                else if (typeof b === 'string') {\n                    var m = loadAsFileSync(path.resolve(x, b));\n                    if (m) return m;\n                }\n                else if (pkg.main) {\n                    var m = loadAsFileSync(path.resolve(x, pkg.main));\n                    if (m) return m;\n                }\n            }\n            \n            return loadAsFileSync(x + '/index');\n        }\n        \n        function loadNodeModulesSync (x, start) {\n            var dirs = nodeModulesPathsSync(start);\n            for (var i = 0; i < dirs.length; i++) {\n                var dir = dirs[i];\n                var m = loadAsFileSync(dir + '/' + x);\n                if (m) return m;\n                var n = loadAsDirectorySync(dir + '/' + x);\n                if (n) return n;\n            }\n            \n            var m = loadAsFileSync(x);\n            if (m) return m;\n        }\n        \n        function nodeModulesPathsSync (start) {\n            var parts;\n            if (start === '/') parts = [ '' ];\n            else parts = path.normalize(start).split('/');\n            \n            var dirs = [];\n            for (var i = parts.length - 1; i >= 0; i--) {\n                if (parts[i] === 'node_modules') continue;\n                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';\n                dirs.push(dir);\n            }\n            \n            return dirs;\n        }\n    };\n})();\n\nrequire.alias = function (from, to) {\n    var path = require.modules.path();\n    var res = null;\n    try {\n        res = require.resolve(from + '/package.json', '/');\n    }\n    catch (err) {\n        res = require.resolve(from, '/');\n    }\n    var basedir = path.dirname(res);\n    \n    var keys = (Object.keys || function (obj) {\n        var res = [];\n        for (var key in obj) res.push(key);\n        return res;\n    })(require.modules);\n    \n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (key.slice(0, basedir.length + 1) === basedir + '/') {\n            var f = key.slice(basedir.length);\n            require.modules[to + f] = require.modules[basedir + f];\n        }\n        else if (key === basedir) {\n            require.modules[to] = require.modules[basedir];\n        }\n    }\n};\n\n(function () {\n    var process = {};\n    var global = typeof window !== 'undefined' ? window : {};\n    var definedProcess = false;\n    \n    require.define = function (filename, fn) {\n        if (!definedProcess && require.modules.__browserify_process) {\n            process = require.modules.__browserify_process();\n            definedProcess = true;\n        }\n        \n        var dirname = require._core[filename]\n            ? ''\n            : require.modules.path().dirname(filename)\n        ;\n        \n        var require_ = function (file) {\n            var requiredModule = require(file, dirname);\n            var cached = require.cache[require.resolve(file, dirname)];\n\n            if (cached && cached.parent === null) {\n                cached.parent = module_;\n            }\n\n            return requiredModule;\n        };\n        require_.resolve = function (name) {\n            return require.resolve(name, dirname);\n        };\n        require_.modules = require.modules;\n        require_.define = require.define;\n        require_.cache = require.cache;\n        var module_ = {\n            id : filename,\n            filename: filename,\n            exports : {},\n            loaded : false,\n            parent: null\n        };\n        \n        require.modules[filename] = function () {\n            require.cache[filename] = module_;\n            fn.call(\n                module_.exports,\n                require_,\n                module_,\n                module_.exports,\n                dirname,\n                filename,\n                process,\n                global\n            );\n            module_.loaded = true;\n            return module_.exports;\n        };\n    };\n})();\n\n\nrequire.define(\"path\",function(require,module,exports,__dirname,__filename,process,global){function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n});\n\nrequire.define(\"__browserify_process\",function(require,module,exports,__dirname,__filename,process,global){var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n});\n\nrequire.define(\"/package.json\",function(require,module,exports,__dirname,__filename,process,global){module.exports = {\"main\":\"index.js\"}\n});\n\nrequire.define(\"/index.js\",function(require,module,exports,__dirname,__filename,process,global){module.exports.meshers = {\n  culled: require('./meshers/culled').mesher,\n  greedy: require('./meshers/greedy').mesher,\n  monotone: require('./meshers/monotone').mesher,\n  stupid: require('./meshers/stupid').mesher\n}\n\nmodule.exports.geometry = {}\nmodule.exports.generator = {}\nmodule.exports.generate = generate\n\n// from https://github.com/mikolalysenko/mikolalysenko.github.com/blob/master/MinecraftMeshes2/js/testdata.js#L4\nfunction generate(l, h, f) {\n  var d = [ h[0]-l[0], h[1]-l[1], h[2]-l[2] ]\n    , v = new Int32Array(d[0]*d[1]*d[2])\n    , n = 0;\n  for(var k=l[2]; k<h[2]; ++k)\n  for(var j=l[1]; j<h[1]; ++j)\n  for(var i=l[0]; i<h[0]; ++i, ++n) {\n    v[n] = f(i,j,k);\n  }\n  return {voxels:v, dims:d};\n}\n\n// shape and terrain generator functions\nmodule.exports.generator['Sphere'] = function(i,j,k) {\n  return i*i+j*j+k*k <= 16*16 ? 0x113344 : 0;\n}\n\nmodule.exports.generator['Noise'] = function(i,j,k) {\n  return Math.random() < 0.1 ? Math.random() * 0xffffff : 0;\n}\n\nmodule.exports.generator['Dense Noise'] = function(i,j,k) {\n  return Math.round(Math.random() * 0xffffff);\n}\n\nmodule.exports.generator['Checker'] = function(i,j,k) {\n  return !!((i+j+k)&1) ? (((i^j^k)&2) ? 1 : 0xffffff) : 0;\n}\n\nmodule.exports.generator['Hill'] = function(i,j,k) {\n  return j <= 16 * Math.exp(-(i*i + k*k) / 64) ? 0x118822 : 0;\n}\n\nmodule.exports.generator['Valley'] = function(i,j,k) {\n  return j <= (i*i + k*k) * 31 / (32*32*2) + 1 ? 0x118822 : 0;\n}\n\nmodule.exports.generator['Hilly Terrain'] = function(i,j,k) {\n  var h0 = 3.0 * Math.sin(Math.PI * i / 12.0 - Math.PI * k * 0.1) + 27;    \n  if(j > h0+1) {\n    return 0;\n  }\n  if(h0 <= j) {\n    return 0x23dd31;\n  }\n  var h1 = 2.0 * Math.sin(Math.PI * i * 0.25 - Math.PI * k * 0.3) + 20;\n  if(h1 <= j) {\n    return 0x964B00;\n  }\n  if(2 < j) {\n    return Math.random() < 0.1 ? 0x222222 : 0xaaaaaa;\n  }\n  return 0xff0000;\n}\n\n// convenience function that uses the above functions to prebake some simple voxel geometries\nmodule.exports.generateExamples = function() {\n  return {\n    'Sphere': generate([-16,-16,-16], [16,16,16], module.exports.generator['Sphere']),\n    'Noise': generate([0,0,0], [16,16,16], module.exports.generator['Noise']),\n    'Dense Noise': generate([0,0,0], [16,16,16], module.exports.generator['Dense Noise']),\n    'Checker': generate([0,0,0], [8,8,8], module.exports.generator['Checker']),\n    'Hill': generate([-16, 0, -16], [16,16,16], module.exports.generator['Hill']),\n    'Valley': generate([0,0,0], [32,32,32], module.exports.generator['Valley']),\n    'Hilly Terrain': generate([0, 0, 0], [32,32,32], module.exports.generator['Hilly Terrain'])\n  }\n}\n\n\n});\n\nrequire.define(\"/meshers/culled.js\",function(require,module,exports,__dirname,__filename,process,global){//Naive meshing (with face culling)\nfunction CulledMesh(volume, dims) {\n  //Precalculate direction vectors for convenience\n  var dir = new Array(3);\n  for(var i=0; i<3; ++i) {\n    dir[i] = [[0,0,0], [0,0,0]];\n    dir[i][0][(i+1)%3] = 1;\n    dir[i][1][(i+2)%3] = 1;\n  }\n  //March over the volume\n  var vertices = []\n    , faces = []\n    , x = [0,0,0]\n    , B = [[false,true]    //Incrementally update bounds (this is a bit ugly)\n          ,[false,true]\n          ,[false,true]]\n    , n = -dims[0]*dims[1];\n  for(           B[2]=[false,true],x[2]=-1; x[2]<dims[2]; B[2]=[true,(++x[2]<dims[2]-1)])\n  for(n-=dims[0],B[1]=[false,true],x[1]=-1; x[1]<dims[1]; B[1]=[true,(++x[1]<dims[1]-1)])\n  for(n-=1,      B[0]=[false,true],x[0]=-1; x[0]<dims[0]; B[0]=[true,(++x[0]<dims[0]-1)], ++n) {\n    //Read current voxel and 3 neighboring voxels using bounds check results\n    var p =   (B[0][0] && B[1][0] && B[2][0]) ? volume[n]                 : 0\n      , b = [ (B[0][1] && B[1][0] && B[2][0]) ? volume[n+1]               : 0\n            , (B[0][0] && B[1][1] && B[2][0]) ? volume[n+dims[0]]         : 0\n            , (B[0][0] && B[1][0] && B[2][1]) ? volume[n+dims[0]*dims[1]] : 0\n          ];\n    //Generate faces\n    for(var d=0; d<3; ++d)\n    if((!!p) !== (!!b[d])) {\n      var s = !p ? 1 : 0;\n      var t = [x[0],x[1],x[2]]\n        , u = dir[d][s]\n        , v = dir[d][s^1];\n      ++t[d];\n      \n      var vertex_count = vertices.length;\n      vertices.push([t[0],           t[1],           t[2]          ]);\n      vertices.push([t[0]+u[0],      t[1]+u[1],      t[2]+u[2]     ]);\n      vertices.push([t[0]+u[0]+v[0], t[1]+u[1]+v[1], t[2]+u[2]+v[2]]);\n      vertices.push([t[0]     +v[0], t[1]     +v[1], t[2]     +v[2]]);\n      faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, s ? b[d] : p]);\n    }\n  }\n  return { vertices:vertices, faces:faces };\n}\n\n\nif(exports) {\n  exports.mesher = CulledMesh;\n}\n\n});\n\nrequire.define(\"/meshers/greedy.js\",function(require,module,exports,__dirname,__filename,process,global){var GreedyMesh = (function() {\n//Cache buffer internally\nvar mask = new Int32Array(4096);\n\nreturn function(volume, dims) {\n  function f(i,j,k) {\n    return volume[i + dims[0] * (j + dims[1] * k)];\n  }\n  //Sweep over 3-axes\n  var vertices = [], faces = [];\n  for(var d=0; d<3; ++d) {\n    var i, j, k, l, w, h\n      , u = (d+1)%3\n      , v = (d+2)%3\n      , x = [0,0,0]\n      , q = [0,0,0];\n    if(mask.length < dims[u] * dims[v]) {\n      mask = new Int32Array(dims[u] * dims[v]);\n    }\n    q[d] = 1;\n    for(x[d]=-1; x[d]<dims[d]; ) {\n      //Compute mask\n      var n = 0;\n      for(x[v]=0; x[v]<dims[v]; ++x[v])\n      for(x[u]=0; x[u]<dims[u]; ++x[u], ++n) {\n        var a = (0    <= x[d]      ? f(x[0],      x[1],      x[2])      : 0)\n          , b = (x[d] <  dims[d]-1 ? f(x[0]+q[0], x[1]+q[1], x[2]+q[2]) : 0);\n        if((!!a) === (!!b) ) {\n          mask[n] = 0;\n        } else if(!!a) {\n          mask[n] = a;\n        } else {\n          mask[n] = -b;\n        }\n      }\n      //Increment x[d]\n      ++x[d];\n      //Generate mesh for mask using lexicographic ordering\n      n = 0;\n      for(j=0; j<dims[v]; ++j)\n      for(i=0; i<dims[u]; ) {\n        var c = mask[n];\n        if(!!c) {\n          //Compute width\n          for(w=1; c === mask[n+w] && i+w<dims[u]; ++w) {\n          }\n          //Compute height (this is slightly awkward\n          var done = false;\n          for(h=1; j+h<dims[v]; ++h) {\n            for(k=0; k<w; ++k) {\n              if(c !== mask[n+k+h*dims[u]]) {\n                done = true;\n                break;\n              }\n            }\n            if(done) {\n              break;\n            }\n          }\n          //Add quad\n          x[u] = i;  x[v] = j;\n          var du = [0,0,0]\n            , dv = [0,0,0]; \n          if(c > 0) {\n            dv[v] = h;\n            du[u] = w;\n          } else {\n            c = -c;\n            du[v] = h;\n            dv[u] = w;\n          }\n          var vertex_count = vertices.length;\n          vertices.push([x[0],             x[1],             x[2]            ]);\n          vertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);\n          vertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);\n          vertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);\n          faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, c]);\n          \n          //Zero-out mask\n          for(l=0; l<h; ++l)\n          for(k=0; k<w; ++k) {\n            mask[n+k+l*dims[u]] = 0;\n          }\n          //Increment counters and continue\n          i += w; n += w;\n        } else {\n          ++i;    ++n;\n        }\n      }\n    }\n  }\n  return { vertices:vertices, faces:faces };\n}\n})();\n\nif(exports) {\n  exports.mesher = GreedyMesh;\n}\n\n});\n\nrequire.define(\"/meshers/monotone.js\",function(require,module,exports,__dirname,__filename,process,global){\"use strict\";\n\nvar MonotoneMesh = (function(){\n\nfunction MonotonePolygon(c, v, ul, ur) {\n  this.color  = c;\n  this.left   = [[ul, v]];\n  this.right  = [[ur, v]];\n};\n\nMonotonePolygon.prototype.close_off = function(v) {\n  this.left.push([ this.left[this.left.length-1][0], v ]);\n  this.right.push([ this.right[this.right.length-1][0], v ]);\n};\n\nMonotonePolygon.prototype.merge_run = function(v, u_l, u_r) {\n  var l = this.left[this.left.length-1][0]\n    , r = this.right[this.right.length-1][0]; \n  if(l !== u_l) {\n    this.left.push([ l, v ]);\n    this.left.push([ u_l, v ]);\n  }\n  if(r !== u_r) {\n    this.right.push([ r, v ]);\n    this.right.push([ u_r, v ]);\n  }\n};\n\n\nreturn function(volume, dims) {\n  function f(i,j,k) {\n    return volume[i + dims[0] * (j + dims[1] * k)];\n  }\n  //Sweep over 3-axes\n  var vertices = [], faces = [];\n  for(var d=0; d<3; ++d) {\n    var i, j, k\n      , u = (d+1)%3   //u and v are orthogonal directions to d\n      , v = (d+2)%3\n      , x = new Int32Array(3)\n      , q = new Int32Array(3)\n      , runs = new Int32Array(2 * (dims[u]+1))\n      , frontier = new Int32Array(dims[u])  //Frontier is list of pointers to polygons\n      , next_frontier = new Int32Array(dims[u])\n      , left_index = new Int32Array(2 * dims[v])\n      , right_index = new Int32Array(2 * dims[v])\n      , stack = new Int32Array(24 * dims[v])\n      , delta = [[0,0], [0,0]];\n    //q points along d-direction\n    q[d] = 1;\n    //Initialize sentinel\n    for(x[d]=-1; x[d]<dims[d]; ) {\n      // --- Perform monotone polygon subdivision ---\n      var n = 0\n        , polygons = []\n        , nf = 0;\n      for(x[v]=0; x[v]<dims[v]; ++x[v]) {\n        //Make one pass over the u-scan line of the volume to run-length encode polygon\n        var nr = 0, p = 0, c = 0;\n        for(x[u]=0; x[u]<dims[u]; ++x[u], p = c) {\n          //Compute the type for this face\n          var a = (0    <= x[d]      ? f(x[0],      x[1],      x[2])      : 0)\n            , b = (x[d] <  dims[d]-1 ? f(x[0]+q[0], x[1]+q[1], x[2]+q[2]) : 0);\n          c = a;\n          if((!a) === (!b)) {\n            c = 0;\n          } else if(!a) {\n            c = -b;\n          }\n          //If cell type doesn't match, start a new run\n          if(p !== c) {\n            runs[nr++] = x[u];\n            runs[nr++] = c;\n          }\n        }\n        //Add sentinel run\n        runs[nr++] = dims[u];\n        runs[nr++] = 0;\n        //Update frontier by merging runs\n        var fp = 0;\n        for(var i=0, j=0; i<nf && j<nr-2; ) {\n          var p    = polygons[frontier[i]]\n            , p_l  = p.left[p.left.length-1][0]\n            , p_r  = p.right[p.right.length-1][0]\n            , p_c  = p.color\n            , r_l  = runs[j]    //Start of run\n            , r_r  = runs[j+2]  //End of run\n            , r_c  = runs[j+1]; //Color of run\n          //Check if we can merge run with polygon\n          if(r_r > p_l && p_r > r_l && r_c === p_c) {\n            //Merge run\n            p.merge_run(x[v], r_l, r_r);\n            //Insert polygon into frontier\n            next_frontier[fp++] = frontier[i];\n            ++i;\n            j += 2;\n          } else {\n            //Check if we need to advance the run pointer\n            if(r_r <= p_r) {\n              if(!!r_c) {\n                var n_poly = new MonotonePolygon(r_c, x[v], r_l, r_r);\n                next_frontier[fp++] = polygons.length;\n                polygons.push(n_poly);\n              }\n              j += 2;\n            }\n            //Check if we need to advance the frontier pointer\n            if(p_r <= r_r) {\n              p.close_off(x[v]);\n              ++i;\n            }\n          }\n        }\n        //Close off any residual polygons\n        for(; i<nf; ++i) {\n          polygons[frontier[i]].close_off(x[v]);\n        }\n        //Add any extra runs to frontier\n        for(; j<nr-2; j+=2) {\n          var r_l  = runs[j]\n            , r_r  = runs[j+2]\n            , r_c  = runs[j+1];\n          if(!!r_c) {\n            var n_poly = new MonotonePolygon(r_c, x[v], r_l, r_r);\n            next_frontier[fp++] = polygons.length;\n            polygons.push(n_poly);\n          }\n        }\n        //Swap frontiers\n        var tmp = next_frontier;\n        next_frontier = frontier;\n        frontier = tmp;\n        nf = fp;\n      }\n      //Close off frontier\n      for(var i=0; i<nf; ++i) {\n        var p = polygons[frontier[i]];\n        p.close_off(dims[v]);\n      }\n      // --- Monotone subdivision of polygon is complete at this point ---\n      \n      x[d]++;\n      \n      //Now we just need to triangulate each monotone polygon\n      for(var i=0; i<polygons.length; ++i) {\n        var p = polygons[i]\n          , c = p.color\n          , flipped = false;\n        if(c < 0) {\n          flipped = true;\n          c = -c;\n        }\n        for(var j=0; j<p.left.length; ++j) {\n          left_index[j] = vertices.length;\n          var y = [0.0,0.0,0.0]\n            , z = p.left[j];\n          y[d] = x[d];\n          y[u] = z[0];\n          y[v] = z[1];\n          vertices.push(y);\n        }\n        for(var j=0; j<p.right.length; ++j) {\n          right_index[j] = vertices.length;\n          var y = [0.0,0.0,0.0]\n            , z = p.right[j];\n          y[d] = x[d];\n          y[u] = z[0];\n          y[v] = z[1];\n          vertices.push(y);\n        }\n        //Triangulate the monotone polygon\n        var bottom = 0\n          , top = 0\n          , l_i = 1\n          , r_i = 1\n          , side = true;  //true = right, false = left\n        \n        stack[top++] = left_index[0];\n        stack[top++] = p.left[0][0];\n        stack[top++] = p.left[0][1];\n        \n        stack[top++] = right_index[0];\n        stack[top++] = p.right[0][0];\n        stack[top++] = p.right[0][1];\n        \n        while(l_i < p.left.length || r_i < p.right.length) {\n          //Compute next side\n          var n_side = false;\n          if(l_i === p.left.length) {\n            n_side = true;\n          } else if(r_i !== p.right.length) {\n            var l = p.left[l_i]\n              , r = p.right[r_i];\n            n_side = l[1] > r[1];\n          }\n          var idx = n_side ? right_index[r_i] : left_index[l_i]\n            , vert = n_side ? p.right[r_i] : p.left[l_i];\n          if(n_side !== side) {\n            //Opposite side\n            while(bottom+3 < top) {\n              if(flipped === n_side) {\n                faces.push([ stack[bottom], stack[bottom+3], idx, c]);\n              } else {\n                faces.push([ stack[bottom+3], stack[bottom], idx, c]);              \n              }\n              bottom += 3;\n            }\n          } else {\n            //Same side\n            while(bottom+3 < top) {\n              //Compute convexity\n              for(var j=0; j<2; ++j)\n              for(var k=0; k<2; ++k) {\n                delta[j][k] = stack[top-3*(j+1)+k+1] - vert[k];\n              }\n              var det = delta[0][0] * delta[1][1] - delta[1][0] * delta[0][1];\n              if(n_side === (det > 0)) {\n                break;\n              }\n              if(det !== 0) {\n                if(flipped === n_side) {\n                  faces.push([ stack[top-3], stack[top-6], idx, c ]);\n                } else {\n                  faces.push([ stack[top-6], stack[top-3], idx, c ]);\n                }\n              }\n              top -= 3;\n            }\n          }\n          //Push vertex\n          stack[top++] = idx;\n          stack[top++] = vert[0];\n          stack[top++] = vert[1];\n          //Update loop index\n          if(n_side) {\n            ++r_i;\n          } else {\n            ++l_i;\n          }\n          side = n_side;\n        }\n      }\n    }\n  }\n  return { vertices:vertices, faces:faces };\n}\n})();\n\nif(exports) {\n  exports.mesher = MonotoneMesh;\n}\n\n});\n\nrequire.define(\"/meshers/stupid.js\",function(require,module,exports,__dirname,__filename,process,global){//The stupidest possible way to generate a Minecraft mesh (I think)\nfunction StupidMesh(volume, dims) {\n  var vertices = [], faces = [], x = [0,0,0], n = 0;\n  for(x[2]=0; x[2]<dims[2]; ++x[2])\n  for(x[1]=0; x[1]<dims[1]; ++x[1])\n  for(x[0]=0; x[0]<dims[0]; ++x[0], ++n)\n  if(!!volume[n]) {\n    for(var d=0; d<3; ++d) {\n      var t = [x[0], x[1], x[2]]\n        , u = [0,0,0]\n        , v = [0,0,0];\n      u[(d+1)%3] = 1;\n      v[(d+2)%3] = 1;\n      for(var s=0; s<2; ++s) {\n        t[d] = x[d] + s;\n        var tmp = u;\n        u = v;\n        v = tmp;\n        var vertex_count = vertices.length;\n        vertices.push([t[0],           t[1],           t[2]          ]);\n        vertices.push([t[0]+u[0],      t[1]+u[1],      t[2]+u[2]     ]);\n        vertices.push([t[0]+u[0]+v[0], t[1]+u[1]+v[1], t[2]+u[2]+v[2]]);\n        vertices.push([t[0]     +v[0], t[1]     +v[1], t[2]     +v[2]]);\n        faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, volume[n]]);\n      }\n    }\n  }\n  return { vertices:vertices, faces:faces };\n}\n\n\nif(exports) {\n  exports.mesher = StupidMesh;\n}\n\n});\n\nrequire.define(\"/test.js\",function(require,module,exports,__dirname,__filename,process,global){voxel = require('./')\n});\nrequire(\"/test.js\");\n})();\n\n","/home/travis/build/npmtest/node-npmtest-voxel/node_modules/voxel/bench/meshers.js":"var meshers = require('../').meshers\n  , generators = require('../').generator\n  , microtime = require('microtime')\n  , times = {}\n\nvar chunkSize = 32\n  , iterations = 10\n\nObject.keys(meshers).forEach(function(mesherName) {\n  var mesher = meshers[mesherName]\n    , meshTimes = times[mesherName] = {}\n\n  process.stdout.write('benchmarking ' + mesherName)\n\n  Object.keys(generators).forEach(function(generatorName) {\n    var generator = generators[generatorName]\n      , array = new Int8Array(4096)\n      , n = 0\n\n    for (var x = 0; x < chunkSize; x += 1)\n      for (var y = 0; y < chunkSize; y += 1)\n        for (var z = 0; z < chunkSize; z += 1, n += 1)\n          array[n] = generator(x, y, z) || 0\n\n    var start = microtime.now()\n    for (var i = 0; i < iterations; i += 1) mesher(array, [chunkSize, chunkSize, chunkSize])\n    meshTimes[generatorName] = microtime.now() - start\n\n    process.stdout.write('.')\n  })\n\n  process.stdout.write('\\n')\n})\n\nfunction limit(n) {\n  return (n + '').slice(0, 6)\n}\n\nconsole.log('\\nResults:')\nObject.keys(times).forEach(function(mesher) {\n  var meshTimes = times[mesher]\n    , meshKeys = Object.keys(meshTimes)\n    , meshTotal = meshKeys.reduce(function(n, k) { return meshTimes[k] + n }, 0)\n\n  console.log(' ' + mesher + ': ' + limit(meshTotal / 1000 / iterations) + 'ms')\n\n  meshKeys.sort(function(a, b) {\n    return meshTimes[a] - meshTimes[b]\n  }).forEach(function(key) {\n    console.log('   ' + key + ': ' + limit(meshTimes[key] / 1000 / iterations) + 'ms')\n  })\n})"}